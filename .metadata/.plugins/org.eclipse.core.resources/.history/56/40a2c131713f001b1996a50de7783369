package com.holub.database;

import com.holub.tools.ArrayIterator;

import java.io.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class XMLImporter implements Table.Importer{
	private BufferedReader  in;			// null once end-of-file reached
	private String[]        columnNames;
	private String          tableName;

	public XMLImporter( Reader in )
	{	this.in = in instanceof BufferedReader
						? (BufferedReader)in
                       : new BufferedReader(in)
	                    ;
	}
	public void startTable()			throws IOException
	{	
		String line = null;
		while((line = in.readLine()) != null) {
			if ( line.contains("<table")) break;   //table 태그 찾고
		}
		
		tableName   = line.split("\"")[1];  //파싱하여 table name 저장
		
		String tmpStr = "";
		String columnStr="";
		int i = 0;
		int j = 0;
		
		
		while((line = in.readLine()) != null) 
		{
			if ( line.contains("row>"))  // row 태그 찾아서 기준으로
				continue;
			else {
				tmpStr = line.trim();  //in.readLine().trim();
				
				//정규식 이용해 각각의 column names를 추출
				//Pattern pattern = Pattern.compile("[>](.*?)[</]");
				Pattern pattern = Pattern.compile("[<](.*?)[>]");
				Matcher matcher = pattern.matcher(tmpStr);
				
				while(matcher.find()) {
					
					  //System.out.println(matcher.group(1));
					  if(j%2 == 0) {
						  columnStr = columnStr.concat(matcher.group(1)+",");
					  }
					  i++;  j++;
		    		    
					  if(matcher.group(1) ==  null)
					    break;
				}
				break;
			}
	    }

		
		columnStr = columnStr.substring(0, columnStr.length()-1);
		columnNames = columnStr.split(","); 
		System.out.println("TABLE NAME ------------" + tableName);
		System.out.println("Column NAMES ----" + columnStr);
	}
		
		
	public String loadTableName()		throws IOException
	{	return tableName;
	}
	
	public int loadWidth()			    throws IOException
	{	return columnNames.length;
	}
	
	public Iterator loadColumnNames()	throws IOException
	{	return new ArrayIterator(columnNames);  //{=CSVImporter.ArrayIteratorCall}
	}

	public Iterator loadRow()			throws IOException
	{	
		String line = null;
		Iterator row = null;
		String tmpStr="";
		String columnValStr="";
		
		while((line = in.readLine()) != null) 
		{				
			if( line == null ) 	in = null;
			else if ( line.contains("row>"))  {
				continue;
			}
			else if ( line.contains("table>"))  {
				continue;
			}
			else {
				tmpStr = line.trim();  //in.readLine().trim();
				System.out.println("@@ ######## 읽어야하는줄 읽엇냐############### @@@@@@@");
				System.out.println(tmpStr);
				
				
				
				//정규식 이용해 각각의 column values를 추출
				Pattern pattern = Pattern.compile("[>](.*?)[<]+[\\/]");
				Matcher matcher = pattern.matcher(tmpStr);
				
				while(matcher.find()) {
					
					  System.out.println("  히히 "+ matcher.group(1));
					  columnValStr = columnValStr.concat(matcher.group(1)+",");
					    
					  if(matcher.group(1) ==  null)
					    break;
				}
				columnValStr = columnValStr.substring(0, columnValStr.length()-1);
				System.out.println("@@ ####################### @@@@@@@");
				
				System.out.println(columnValStr);
				row = new ArrayIterator( columnValStr.split(","));
				break;
			}
		}
		return row;
	}

	public void endTable() throws IOException {}
}



/*  (c) 2004 Allen I. Holub. All rights reserved.
*
*  This code may be used freely by yourself with the following
*  restrictions:
*
*  o Your splash screen, about box, or equivalent, must include
*    Allen Holub's name, copyright, and URL. For example:
*
*      This program contains Allen Holub's SQL package.<br>
*      (c) 2005 Allen I. Holub. All Rights Reserved.<br>
*              http://www.holub.com<br>
*
*    If your program does not run interactively, then the foregoing
*    notice must appear in your documentation.
*
*  o You may not redistribute (or mirror) the source code.
*
*  o You must report any bugs that you find to me. Use the form at
*    http://www.holub.com/company/contact.html or send email to
*    allen@Holub.com.
*
*  o The software is supplied <em>as is</em>. Neither Allen Holub nor
*    Holub Associates are responsible for any bugs (or any problems
*    caused by bugs, including lost productivity or data)
*    in any of this code.
*/

/***
*	Pass this importer to a {@link Table} constructor (such
*	as
*	{link com.holub.database.ConcreteTable#ConcreteTable(Table.Importer)}
*	to initialize
*	a <code>Table</code> from
*	a comma-sparated-value repressentation. For example:
*	<PRE>
*	Reader in = new FileReader( "people.csv" );
*	people = new ConcreteTable( new CSVImporter(in) );
*	in.close();
*	</PRE>
*	The input file for a table called "name" with
*	columns "first," "last," and "addrId" would look
*	like this:
*	<PRE>
*	name
*	first,	last,	addrId
*	Fred,	Flintstone,	1
*	Wilma,	Flintstone,	1
*	Allen,	Holub,	0
*	</PRE>
*	The first line is the table name, the second line
*	identifies the columns, and the subsequent lines define
*	the rows.
*
* @include /etc/license.txt
*
* @see Table
* @see Table.Importer
* @see CSVExporter
*/

